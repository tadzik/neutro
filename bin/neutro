#!/usr/bin/env perl6
use v6;
use File::Mkdir;
use File::Copy;
use Module::Build;
use Module::Test;
use Module::Install;
use JSON::Tiny;

# Yay globals!
my $home       = ($*VM<config><osname> eq 'MSWin32')
                 ?? %*ENV<HOMEPATH> !! %*ENV<HOME>;
my $CONFIGDIR  = "$home/.neutro";
my $DESTDIR    = %*ENV<DESTDIR> ne "" ?? %*ENV<DESTDIR>
                                      !! "$home/.perl6";
my $INSTALLED  = "$CONFIGDIR/installed";
my $SRCDIR     = "$CONFIGDIR/src";
my $STRICT     = False;
my $NOTEST     = False;
my $VERBOSE    = False;
my %modules;

#
# Execute a block of code in a given directory
#
sub indir (Str $where, Callable $what) {
    my $old = cwd;
    mkdir $where, :p;
    chdir $where;
    $what();
    chdir $old;
}

#
# Ensure the modules list is present
#
sub checklist {
    unless $CONFIGDIR.IO ~~ :d {
        mkdir $CONFIGDIR, :p;
    }
    unless "$CONFIGDIR/projects.json".IO ~~ :f {
        updatedb;
    }
    # the database of installed modules
    unless $INSTALLED.IO ~~ :f {
        open($INSTALLED, :w).close;
    }

    my $list = from-json(slurp "$CONFIGDIR/projects.json");
    for $list.list -> $mod {
        %modules{$mod<name>} = $mod;
    }
}

#
# Terminate a program yelling
#
sub crap (Str $msg) {
    notice $msg;
    exit 1;
}

#
# Translate a module name to a directory name
# :: would break paths in PERL6LIB for example
#
sub dirname (Str $mod) {
    $mod.subst(':', '_', :g);
}

#
# Download/update the given module
#
sub fetch (Str $name, Str $url) {
    my $res;
    my $dir = dirname($name);
    indir $SRCDIR, {
        notice "Fetching $name";
        if "$SRCDIR/$dir".IO ~~ :d {
            indir $dir, {
                $res = run 'git pull -q';
                crap "Failed updating the $name repo" if $res;
            };
        } else {
            $res = run "git clone -q $url $dir";
            crap "Failed cloning the $name repo" if $res;
        }
    };
}

#
# Install the specified module
#
sub install (Str $module) {
    my $res;
    my $path;
    if %modules.exists($module) {
        unless %modules{$module}<repo-type> eq 'git' {
            crap 'repo-type other than git NYI';
        }
        fetch $module, %modules{$module}<repo-url>;
    }
    $path = modulepath($module)
            or crap "Unknown module or path '$module'";

    installdeps $module;

    notice "Building $module";
    my $fail = False;
    try {
        Module::Build::build :dir($path), :v($VERBOSE);
        CATCH {
            $fail = True;
        }
    }
    crap "Building $module failed" if $fail;

    unless $NOTEST {
        if $STRICT and "$path/t".IO !~~ :d {
            crap "No tests for $module";
        }
        notice "Testing $module";
        try {
            Module::Test::test :dir($path), :v($VERBOSE);
            CATCH {
                $fail = True;
            }
        }
        crap "Tests failed for $module" if $fail;
    }

    notice "Installing $module";
    try {
        Module::Install::install :dir($path), :dest($DESTDIR),
                                 :v($VERBOSE);
        CATCH {
            $fail = True;
        }
    }
    crap "Installing $module failed" if $fail;

    notice "Successfully installed $module";

    unless isinstalled $module {
        given open($INSTALLED, :a) {
            .say($module);
            .close;
        }
    }
}

#
# Install the dependencies of a module
#
sub installdeps (Str $module) {
    my @deps;
    if %modules.exists($module) {
        @deps = %modules{$module}<depends>.list
    } else {
        my $data = from-json slurp 'META.info';
        @deps = $data<depends>.list;
    }
    for @deps -> $dep {
        unless isinstalled $dep {
            notice "$module depends on $dep, installing";
            install $dep;
        }
    }
}

#
# Check if a module is installed
#
sub isinstalled (Str $module) {
    my $isit;
    given open($INSTALLED) {
        $isit = .lines.first($module).Bool;
        .close;
    }
    return $isit;
}

#
# Print a list of available modules
#
sub listmodules {
    for %modules.keys.sort {
        say $_ => %modules{$_}<description>
    }
}

#
# Get a path of a module's files
#
sub modulepath(Str $mod) {
    return %modules.exists($mod) ?? "$SRCDIR/{dirname($mod)}"
                                 !! $mod.IO ~~ :d ?? $mod !! Nil;
}

#
# Print a message the fancy way
#
sub notice (Str $what) {
    say "==> $what";
}

#
# Update the modules database
#
sub updatedb {
    notice 'Updating modules database';
    indir $CONFIGDIR, {
        unlink 'projects.json' if 'projects.json'.IO ~~ :e;
        fetch 'ecosystem', 'git://github.com/tadzik/ecosystem.git';
        indir "$SRCDIR/ecosystem", {
            my @list;

            my $fh = open('META.list');
            for $fh.lines -> $url {
                run "wget --no-check-certificate $url"
                    and die "Failed fetching $url";
                my $info = from-json(slurp('META.info'));
                @list.push($info);
                unlink 'META.info';
            }

            given open('projects.json', :w) {
                .say(to-json @list);
                .close;
            }

            $fh.close;
        };
        cp "$SRCDIR/ecosystem/projects.json", "$CONFIGDIR/projects.json";
    };
}

multi MAIN ('list') {
    checklist;
    listmodules;
}

multi MAIN ('update') {
    updatedb;
}

multi MAIN ($module,
            Bool :$strict = False,
            Bool :$v      = False,
            Bool :$notest = False) {
    checklist;
    $STRICT  = $strict;
    $VERBOSE = $v;
    $NOTEST  = $notest;
    install $module;
}

# vim: ft=perl6
