#!/usr/bin/env perl6
use v6;
use File::Mkdir;
use File::Copy;
use Module::Build;
use Module::Test;
use Module::Install;
use JSON::Tiny;

#
# Terminate a program yelling
#
sub crap (Str $msg) {
    notice $msg;
    exit 1;
}

#
# Execute a block of code in a given directory
#
sub indir (Str $where, Callable $what) {
    my $old = cwd;
    mkdir $where, :p;
    chdir $where;
    $what();
    chdir $old;
}

#
# Print a message the fancy way
#
sub notice (Str $what) {
    say "==> $what";
}

package Settings {
    our $home       = ($*VM<config><osname> eq 'MSWin32')
                      ?? %*ENV<HOMEPATH> !! %*ENV<HOME>;
    our $configdir  = "$home/.neutro";
    our $destdir    = %*ENV<DESTDIR> ne "" ?? %*ENV<DESTDIR>
                                           !! "$home/.perl6";
    our $srcdir     = "$configdir/src";
    our $nodeps     = False;
    our $notest     = False;
    our $verbose    = False;

    our sub init {
        unless $configdir.IO ~~ :d {
            mkdir $configdir, :p;
        }
    }

    #
    # Translate a module name to a directory name
    # :: would break paths in PERL6LIB for example
    #
    our sub dirname (Str $mod) {
        $mod.subst(':', '_', :g);
    }
}

package Ecosystem {
    our $installed  = "{$Settings::configdir}/installed";
    our %modules;

    our sub init {
        Settings::init();
        unless "{$Settings::configdir}/projects.json".IO ~~ :f {
            updatedb;
        }
        # the database of installed modules
        unless $installed.IO ~~ :f {
            open($installed, :w).close;
        }

        my $list = from-json(slurp "{$Settings::configdir}/projects.json");
        for $list.list -> $mod {
            %modules{$mod<name>} = $mod;
        }
    }

    #
    # Download/update the given module
    #
    our sub fetch (Str $name, Str $url) {
        my $res;
        my $dir = Settings::dirname($name);
        indir $Settings::srcdir, {
            notice "Fetching $name";
            if "{$Settings::srcdir}/$dir".IO ~~ :d {
                indir $dir, {
                    $res = run 'git pull -q';
                    die "Failed updating the $name repo" if $res;
                };
            } else {
                $res = run "git clone -q $url $dir";
                die "Failed cloning the $name repo" if $res;
            }
        };
        # returns the directory where the module lies
        return {$Settings::srcdir} ~ "/$name";
    }
    #
    # Check if a module is installed
    #
    our sub isinstalled (Str $module) {
        my $isit;
        given open($installed) {
            $isit = .lines.first($module).Bool;
            .close;
        }
        return $isit;
    }

    our sub listinstalled {
        given open($installed) {
            for .lines {
                printf "%-20s\t%s\n", $_, %modules{$_}<description>
                                          // 'not found in the ecosystem'
            }
            .close;
        }
    }

    #
    # Print a list of available modules
    #
    our sub listmodules {
        for %modules.keys.sort {
            printf "%-20s\t%s\n", $_, %modules{$_}<description>
        }
    }

    #
    # Update the modules database
    #
    our sub updatedb {
        notice 'Updating modules database';
        indir $Settings::configdir, {
            unlink 'projects.json' if 'projects.json'.IO ~~ :e;
            fetch 'ecosystem', 'git://github.com/tadzik/ecosystem.git';
            indir "{$Settings::srcdir}/ecosystem", {
                my @list;

                my $fh = open('META.list');
                for $fh.lines -> $url {
                    run "wget -q --no-check-certificate $url"
                        and die "Failed fetching $url";
                    my $info = from-json(slurp('META.info'));
                    @list.push($info);
                    unlink 'META.info';
                }

                given open('projects.json', :w) {
                    .say(to-json @list);
                    .close;
                }

                $fh.close;
            };
            cp "{$Settings::srcdir}/ecosystem/projects.json",
               "{$Settings::configdir}/projects.json";
        };
    }
}

#
# Install the specified module
#
sub install (Str $module is rw) {
    my $path;
    my $meta;
    if %Ecosystem::modules.exists($module) {
        $meta = %Ecosystem::modules{$module};
        unless $meta<repo-type> eq 'git' {
            crap 'repo-type other than git NYI';
        }
        try {
            $path = Ecosystem::fetch $module, $meta<repo-url>;
            CATCH {
                crap $!;
            }
        }
    } elsif "$module/META.info".IO ~~ :f {
        $path = $module;
        $meta = from-json slurp "$module/META.info";
        $module = $meta<name>;
    } else {
        crap "Module $module not in the ecosystem "
             ~ "(or no module files in directory $module)";
    }

    installdeps $meta unless $Settings::nodeps;

    notice "Building $module";
    my $fail = False;
    try {
        Module::Build::build :dir($path), :v($Settings::verbose);
        CATCH {
            $fail = True;
        }
    }
    crap "Building $module failed" if $fail;

    unless $Settings::notest || "$path/t".IO !~~ :d {
        notice "Testing $module";
        try {
            Module::Test::test :dir($path), :v($Settings::verbose);
            CATCH {
                $fail = True;
            }
        }
        crap "Tests failed for $module" if $fail;
    }

    notice "Installing $module";
    try {
        Module::Install::install :dir($path), :dest($Settings::destdir),
                                 :v($Settings::verbose);
        CATCH {
            $fail = True;
        }
    }
    crap "Installing $module failed" if $fail;

    notice "Successfully installed $module";

    unless Ecosystem::isinstalled $module {
        given open($Ecosystem::installed, :a) {
            .say($module);
            .close;
        }
    }
}

#
# Install the dependencies of a module
#
sub installdeps ($meta) {
    for $meta<depends>.list -> $dep {
        unless Ecosystem::isinstalled $dep {
            notice "$meta<name> depends on $dep, installing";
            install $dep;
        }
    }
}

sub MAIN (Bool :$v        = False,
          Bool :$help     = False,
          Bool :$listinst = False,
          Bool :$list     = False,
          Bool :$nodeps   = False,
          Bool :$notest   = False,
          Bool :$update   = False,
          *@args) {
    Ecosystem::init();

    $Settings::verbose = $v;
    $Settings::notest  = $notest;
    $Settings::nodeps  = $nodeps;

    $help     && USAGE();
    $update   && Ecosystem::updatedb();
    $list     && Ecosystem::listmodules();
    $listinst && Ecosystem::listinstalled();

    @argsÂ».&install;
    if none(+@args, $listinst, $list, $update) { say "Nothing to do" }
}

sub USAGE {
    say "Usage: neutro [options] Module1 Module2 ...

Options:
    --v         Be verbose
    --help      Display this message and quit
    --list      List the available packages
    --listinst  List the installed packages (installed by/known to neutro)
    --nodeps    Don't install dependencies of modules
    --notest    Don't run unit tests for modules
    --update    Update the module database

Examples:
    # install the NativeCall module w/o running its tests
    neutro --notest NativeCall

    # install from the current directory
    neutro --nodeps .

    # as above, but from the path ./foo/bar
    neutro ./foo/bar

    # update the module database and show the list of available modules
    neutro --update --list

    # install neutro to a directory 'mylib'
    # NOTE: This will NOT install neutro dependencies
    # if they're alredy installed
    DESTDIR=mylib neutro neutro
";

    exit 0;
}

# vim: ft=perl6
