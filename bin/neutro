#!/usr/bin/env perl6
use v6;
use File::Mkdir;
use File::Copy;
use Module::Build;
use Module::Test;
use Module::Install;
use JSON::Tiny;

#
# Terminate a program yelling
#
sub crap (Str $msg) {
    notice $msg;
    exit 1;
}

#
# Execute a block of code in a given directory
#
sub indir (Str $where, Callable $what) {
    my $old = cwd;
    mkdir $where, :p;
    chdir $where;
    $what();
    chdir $old;
}

#
# Print a message the fancy way
#
sub notice (Str $what) {
    say "==> $what";
}

package Settings {
    our $home       = ($*VM<config><osname> eq 'MSWin32')
                      ?? %*ENV<HOMEPATH> !! %*ENV<HOME>;
    our $configdir  = "$home/.neutro";
    our $destdir    = %*ENV<DESTDIR> ne "" ?? %*ENV<DESTDIR>
                                           !! "$home/.perl6";
    our $srcdir     = "$configdir/src";
    our $notest     = False;
    our $verbose    = False;

    our sub init {
        unless $configdir.IO ~~ :d {
            mkdir $configdir, :p;
        }
    }

    #
    # Translate a module name to a directory name
    # :: would break paths in PERL6LIB for example
    #
    our sub dirname (Str $mod) {
        $mod.subst(':', '_', :g);
    }
}

package Ecosystem {
    our $installed  = "{$Settings::configdir}/installed";
    our %modules;

    our sub init {
        Settings::init();
        unless "{$Settings::configdir}/projects.json".IO ~~ :f {
            updatedb;
        }
        # the database of installed modules
        unless $installed.IO ~~ :f {
            open($installed, :w).close;
        }

        my $list = from-json(slurp "{$Settings::configdir}/projects.json");
        for $list.list -> $mod {
            %modules{$mod<name>} = $mod;
        }
    }

    #
    # Download/update the given module
    #
    our sub fetch (Str $name, Str $url) {
        my $res;
        my $dir = Settings::dirname($name);
        indir $Settings::srcdir, {
            notice "Fetching $name";
            if "{$Settings::srcdir}/$dir".IO ~~ :d {
                indir $dir, {
                    $res = run 'git pull -q';
                    die "Failed updating the $name repo" if $res;
                };
            } else {
                $res = run "git clone -q $url $dir";
                die "Failed cloning the $name repo" if $res;
            }
        };
    }
    #
    # Check if a module is installed
    #
    our sub isinstalled (Str $module) {
        my $isit;
        given open($installed) {
            $isit = .lines.first($module).Bool;
            .close;
        }
        return $isit;
    }

    #
    # Print a list of available modules
    #
    our sub listmodules {
        for %modules.keys.sort {
            printf "%-20s\t%s\n", $_, %modules{$_}<description>
        }
    }

    #
    # Get a path of a module's files
    #
    our sub modulepath(Str $mod) {
        return %modules.exists($mod) 
               ?? "{$Settings::srcdir}/{Settings::dirname($mod)}"
               !! $mod.IO ~~ :d ?? $mod !! Nil;
    }

    #
    # Update the modules database
    #
    our sub updatedb {
        notice 'Updating modules database';
        indir $Settings::configdir, {
            unlink 'projects.json' if 'projects.json'.IO ~~ :e;
            fetch 'ecosystem', 'git://github.com/tadzik/ecosystem.git';
            indir "{$Settings::srcdir}/ecosystem", {
                my @list;

                my $fh = open('META.list');
                for $fh.lines -> $url {
                    run "wget --no-check-certificate $url"
                        and die "Failed fetching $url";
                    my $info = from-json(slurp('META.info'));
                    @list.push($info);
                    unlink 'META.info';
                }

                given open('projects.json', :w) {
                    .say(to-json @list);
                    .close;
                }

                $fh.close;
            };
            cp "{$Settings::srcdir}/ecosystem/projects.json",
               "{$Settings::configdir}/projects.json";
        };
    }
}

#
# Install the specified module
#
sub install (Str $module) {
    my $res;
    my $path;
    if %Ecosystem::modules.exists($module) {
        unless %Ecosystem::modules{$module}<repo-type> eq 'git' {
            crap 'repo-type other than git NYI';
        }
        try {
            Ecosystem::fetch $module, %Ecosystem::modules{$module}<repo-url>;
            CATCH {
                crap $!;
            }
        }
    }
    $path = Ecosystem::modulepath($module)
            or crap "Unknown module or path '$module'";

    installdeps $module;

    notice "Building $module";
    my $fail = False;
    try {
        Module::Build::build :dir($path), :v($Settings::verbose);
        CATCH {
            $fail = True;
        }
    }
    crap "Building $module failed" if $fail;

    unless $Settings::notest || "$path/t".IO !~~ :d {
        notice "Testing $module";
        try {
            Module::Test::test :dir($path), :v($Settings::verbose);
            CATCH {
                $fail = True;
            }
        }
        crap "Tests failed for $module" if $fail;
    }

    notice "Installing $module";
    try {
        Module::Install::install :dir($path), :dest($Settings::destdir),
                                 :v($Settings::verbose);
        CATCH {
            $fail = True;
        }
    }
    crap "Installing $module failed" if $fail;

    notice "Successfully installed $module";

    unless Ecosystem::isinstalled $module {
        given open($Ecosystem::installed, :a) {
            .say($module);
            .close;
        }
    }
}

#
# Install the dependencies of a module
#
sub installdeps (Str $module) {
    my @deps;
    if %Ecosystem::modules.exists($module) {
        @deps = %Ecosystem::modules{$module}<depends>.list
    } else {
        my $data = from-json slurp 'META.info';
        @deps = $data<depends>.list;
    }
    for @deps -> $dep {
        unless Ecosystem::isinstalled $dep {
            notice "$module depends on $dep, installing";
            install $dep;
        }
    }
}

sub MAIN (Bool :$v      = False,
          Bool :$notest = False,
          *@args where { +@args }) {
    Ecosystem::init();
    $Settings::verbose = $v;
    $Settings::notest  = $notest;
    given @args {
        when 'list' {
            Ecosystem::listmodules();
        }
        when 'update' {
            Ecosystem::updatedb();
        }
        default {
            @argsÂ».&install;
        }
    }
}

# vim: ft=perl6
